"""
Pydantic models for escalation management.

These models define the schema for API requests and responses
related to the escalation system.
"""

from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Optional, List, Dict, Any
from datetime import datetime
from uuid import UUID
from enum import Enum


class EscalationStatus(str, Enum):
    """Valid escalation statuses."""
    OPEN = "open"
    ASSIGNED = "assigned"
    RESOLVED = "resolved"
    DECLINED = "declined"


class EscalationPriority(str, Enum):
    """Escalation priority."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


class DateRange(BaseModel):
    """Date range for appointment search."""
    start_date: str = Field(..., description="ISO 8601 date string (YYYY-MM-DD or full datetime)")
    end_date: str = Field(..., description="ISO 8601 date string (YYYY-MM-DD or full datetime)")

    @field_validator('start_date', 'end_date')
    @classmethod
    def validate_date_format(cls, v):
        """Validate that date strings can be parsed."""
        try:
            datetime.fromisoformat(v)
            return v
        except (ValueError, TypeError):
            raise ValueError(f"Invalid date format: {v}. Expected ISO 8601 format.")


class HardConstraints(BaseModel):
    """Hard constraints for appointment scheduling."""
    doctor_id: Optional[UUID] = Field(None, description="Required doctor UUID")
    room_id: Optional[UUID] = Field(None, description="Required room UUID")
    time_of_day: Optional[str] = Field(None, description="Preferred time of day: 'morning', 'afternoon', 'evening'")

    @field_validator('time_of_day')
    @classmethod
    def validate_time_of_day(cls, v):
        """Validate time_of_day is a valid option."""
        if v is not None and v not in ['morning', 'afternoon', 'evening']:
            raise ValueError("time_of_day must be 'morning', 'afternoon', or 'evening'")
        return v


class EscalationRequestData(BaseModel):
    """
    Original booking request that failed auto-scheduling.

    This is stored in the escalation record for context.
    """
    service_id: UUID = Field(..., description="UUID of the requested service")
    patient_id: UUID = Field(..., description="UUID of the patient")
    date_range: DateRange = Field(..., description="Desired date range for appointment")
    hard_constraints: Optional[HardConstraints] = Field(None, description="Hard constraints that must be satisfied")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "service_id": "123e4567-e89b-12d3-a456-426614174000",
                "patient_id": "123e4567-e89b-12d3-a456-426614174001",
                "date_range": {
                    "start_date": "2025-10-15",
                    "end_date": "2025-10-20"
                },
                "hard_constraints": {
                    "doctor_id": "123e4567-e89b-12d3-a456-426614174002",
                    "time_of_day": "morning"
                }
            }
        }
    )


class EscalationSuggestion(BaseModel):
    """Alternative suggestion generated by relaxing constraints."""
    strategy: str = Field(..., description="Name of the relaxation strategy applied")
    request: Dict[str, Any] = Field(..., description="Modified request with relaxed constraints")
    description: str = Field(..., description="User-friendly explanation of the suggestion")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "strategy": "expanded_date_range_3d",
                "request": {
                    "service_id": "123e4567-e89b-12d3-a456-426614174000",
                    "patient_id": "123e4567-e89b-12d3-a456-426614174001",
                    "date_range": {
                        "start_date": "2025-10-15",
                        "end_date": "2025-10-23"
                    }
                },
                "description": "Try dates 3 days later than your preferred range"
            }
        }
    )


class EscalationCreate(BaseModel):
    """Request to create a new escalation."""
    clinic_id: UUID = Field(..., description="UUID of the clinic")
    request: EscalationRequestData = Field(..., description="Original booking request")
    reason: str = Field(..., description="Why auto-scheduling failed")
    suggestions: Optional[List[EscalationSuggestion]] = Field(
        None,
        description="Optional pre-generated suggestions (will auto-generate if not provided)"
    )


class ManualSlot(BaseModel):
    """Manually selected appointment slot."""
    start_time: str = Field(..., description="ISO 8601 datetime string")
    end_time: str = Field(..., description="ISO 8601 datetime string")
    doctor_id: UUID = Field(..., description="UUID of the doctor")
    room_id: Optional[UUID] = Field(None, description="Optional room UUID")

    @field_validator('start_time', 'end_time')
    @classmethod
    def validate_datetime_format(cls, v):
        """Validate that datetime strings can be parsed."""
        try:
            datetime.fromisoformat(v)
            return v
        except (ValueError, TypeError):
            raise ValueError(f"Invalid datetime format: {v}. Expected ISO 8601 format.")


class EscalationResolution(BaseModel):
    """Request to resolve an escalation."""
    selected_suggestion_index: Optional[int] = Field(
        None,
        description="0-based index of selected suggestion from suggestions array",
        ge=0
    )
    manual_slot: Optional[ManualSlot] = Field(
        None,
        description="Manually selected slot (alternative to picking a suggestion)"
    )
    note: Optional[str] = Field(None, description="Optional resolution notes")
    resolved_by: UUID = Field(..., description="UUID of staff member resolving the escalation")

    model_config = ConfigDict(
        json_schema_extra={
            "example_suggestion": {
                "selected_suggestion_index": 0,
                "note": "Patient agreed to morning time",
                "resolved_by": "123e4567-e89b-12d3-a456-426614174003"
            },
            "example_manual": {
                "manual_slot": {
                    "start_time": "2025-10-15T10:00:00",
                    "end_time": "2025-10-15T10:30:00",
                    "doctor_id": "123e4567-e89b-12d3-a456-426614174002"
                },
                "note": "Found slot after cancellation",
                "resolved_by": "123e4567-e89b-12d3-a456-426614174003"
            }
        }
    )


class EscalationAssignment(BaseModel):
    """Request to assign an escalation to staff."""
    assigned_to: UUID = Field(..., description="UUID of staff member to assign to")


class EscalationDecline(BaseModel):
    """Request to decline an escalation."""
    reason: str = Field(..., description="Why the escalation is being declined")
    declined_by: UUID = Field(..., description="UUID of staff member declining it")


class EscalationResponse(BaseModel):
    """Response model for escalation records."""
    id: UUID = Field(..., description="Escalation UUID")
    clinic_id: UUID = Field(..., description="Clinic UUID")
    status: EscalationStatus = Field(..., description="Current escalation status")
    request: Dict[str, Any] = Field(..., description="Original booking request")
    reason: str = Field(..., description="Why auto-scheduling failed")
    suggestions: List[Dict[str, Any]] = Field(..., description="Alternative suggestions")
    assigned_to: Optional[UUID] = Field(None, description="UUID of assigned staff member")
    sla_deadline: datetime = Field(..., description="Deadline for resolution")
    created_at: datetime = Field(..., description="When escalation was created")
    resolved_at: Optional[datetime] = Field(None, description="When escalation was resolved")
    resolution_note: Optional[str] = Field(None, description="Resolution notes")

    model_config = ConfigDict(
        from_attributes=True,
        json_schema_extra={
            "example": {
                "id": "123e4567-e89b-12d3-a456-426614174010",
                "clinic_id": "123e4567-e89b-12d3-a456-426614174011",
                "status": "open",
                "request": {
                    "service_id": "123e4567-e89b-12d3-a456-426614174000",
                    "patient_id": "123e4567-e89b-12d3-a456-426614174001",
                    "date_range": {
                        "start_date": "2025-10-15",
                        "end_date": "2025-10-20"
                    }
                },
                "reason": "No available slots found",
                "suggestions": [
                    {
                        "strategy": "expanded_date_range_3d",
                        "request": {},
                        "description": "Try dates 3 days later"
                    }
                ],
                "sla_deadline": "2025-10-11T12:00:00",
                "created_at": "2025-10-10T12:00:00"
            }
        }
    )


class AppointmentResponse(BaseModel):
    """Response model for created appointment."""
    id: UUID = Field(..., description="Appointment UUID")
    escalation_id: Optional[UUID] = Field(None, description="Escalation UUID if created from escalation")
    clinic_id: UUID = Field(..., description="Clinic UUID")
    patient_id: UUID = Field(..., description="Patient UUID")
    service_id: UUID = Field(..., description="Service UUID")
    status: str = Field(..., description="Appointment status")
    created_by: UUID = Field(..., description="UUID of user who created it")
    created_at: datetime = Field(..., description="When appointment was created")
    note: Optional[str] = Field(None, description="Additional notes")

    model_config = ConfigDict(from_attributes=True)
