"""
Typed action proposals requiring human confirmation.
Pattern from Doctolib Alfred architecture.

Per Opinion 4, Section 5.2:
"Agents never directly commit irreversible actions. Instead they produce an ActionProposal object."

Usage:
    # Agent produces proposal
    proposal = ActionProposal(
        type=ActionProposalType.BOOK_APPOINTMENT,
        patient_id="patient123",
        provider_id="doctor456",
        slot={"date": "2024-01-15", "time": "14:00"},
        human_summary="Book dental cleaning with Dr. Smith on Jan 15 at 2pm",
        execution_params={
            "patient_id": "patient123",
            "doctor_id": "doctor456",
            "datetime": "2024-01-15T14:00:00",
            "service_type": "dental_cleaning"
        }
    )

    # Check if proposal is still valid
    if proposal.is_expired():
        # Handle expired proposal

    # Generate confirmation message
    message = proposal.to_confirmation_message("es")
"""
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from enum import Enum
from datetime import datetime, timezone


class ActionProposalType(str, Enum):
    """Types of actions that require confirmation."""
    BOOK_APPOINTMENT = "schedule_appointment"
    CANCEL_APPOINTMENT = "cancel_appointment"
    RESCHEDULE_APPOINTMENT = "reschedule_appointment"
    UPDATE_CONTACT = "update_contact_info"


class ActionProposal(BaseModel):
    """
    Typed action proposal.
    Generated by agents, verified deterministically, executed only after confirmation.

    IMPORTANT: Proposals have a TTL to prevent "zombie" confirmations.
    If user doesn't respond within TTL, proposal is cleared on next message.

    Per Opinion 3 feedback: Added TTL handling to prevent:
    - User asks about booking
    - User gets confirmation request
    - User forgets about it for 2 days
    - User sends "My throat hurts"
    - Agent incorrectly interprets this as confirmation
    """
    type: ActionProposalType
    patient_id: str
    provider_id: Optional[str] = None
    slot: Optional[Dict[str, Any]] = None
    requires_confirmation: bool = True

    # Human-readable summary for confirmation
    human_summary: str

    # Machine-readable params for execution
    execution_params: Dict[str, Any] = Field(default_factory=dict)

    # TTL handling - proposal expires after this time
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    ttl_seconds: int = 3600  # 1 hour default

    # Tracking
    proposal_id: Optional[str] = None
    confirmed: bool = False
    confirmed_at: Optional[datetime] = None

    def is_expired(self) -> bool:
        """Check if proposal has expired (TTL exceeded)."""
        age = (datetime.now(timezone.utc) - self.created_at).total_seconds()
        return age > self.ttl_seconds

    def age_seconds(self) -> float:
        """Get age of proposal in seconds."""
        return (datetime.now(timezone.utc) - self.created_at).total_seconds()

    def age_human_readable(self) -> str:
        """Get human-readable age string."""
        age = self.age_seconds()
        if age < 60:
            return f"{int(age)} seconds"
        elif age < 3600:
            return f"{int(age / 60)} minutes"
        else:
            return f"{int(age / 3600)} hours"

    def to_confirmation_message(self, language: str = 'en') -> str:
        """Generate confirmation request message in user's language."""
        templates = {
            'en': (
                f"Please confirm: {self.human_summary}\n\n"
                "Reply 'yes' to confirm or 'no' to cancel."
            ),
            'es': (
                f"Por favor confirme: {self.human_summary}\n\n"
                "Responda 'sí' para confirmar o 'no' para cancelar."
            ),
            'ru': (
                f"Пожалуйста, подтвердите: {self.human_summary}\n\n"
                "Ответьте 'да' для подтверждения или 'нет' для отмены."
            ),
            'pt': (
                f"Por favor confirme: {self.human_summary}\n\n"
                "Responda 'sim' para confirmar ou 'não' para cancelar."
            ),
            'he': (
                f"אנא אשר: {self.human_summary}\n\n"
                "השב 'כן' לאישור או 'לא' לביטול."
            ),
        }
        return templates.get(language, templates['en'])

    def to_state_dict(self) -> Dict[str, Any]:
        """Convert proposal to dictionary for graph state storage."""
        return {
            "type": self.type.value,
            "patient_id": self.patient_id,
            "provider_id": self.provider_id,
            "slot": self.slot,
            "requires_confirmation": self.requires_confirmation,
            "human_summary": self.human_summary,
            "execution_params": self.execution_params,
            "created_at": self.created_at.isoformat(),
            "ttl_seconds": self.ttl_seconds,
            "proposal_id": self.proposal_id,
            "confirmed": self.confirmed,
            "confirmed_at": self.confirmed_at.isoformat() if self.confirmed_at else None,
        }

    @classmethod
    def from_state_dict(cls, data: Dict[str, Any]) -> "ActionProposal":
        """Reconstruct proposal from graph state dictionary."""
        if data.get("created_at"):
            if isinstance(data["created_at"], str):
                data["created_at"] = datetime.fromisoformat(data["created_at"].replace("Z", "+00:00"))
        if data.get("confirmed_at"):
            if isinstance(data["confirmed_at"], str):
                data["confirmed_at"] = datetime.fromisoformat(data["confirmed_at"].replace("Z", "+00:00"))
        if data.get("type"):
            if isinstance(data["type"], str):
                data["type"] = ActionProposalType(data["type"])
        return cls(**data)


def is_confirmation_response(message: str, language: str = 'en') -> Optional[bool]:
    """
    Check if a message is a confirmation or rejection response.

    Returns:
        True if confirmation, False if rejection, None if neither
    """
    message_lower = message.lower().strip()

    # Confirmation words by language
    confirm_words = {
        'en': ['yes', 'yeah', 'yep', 'sure', 'ok', 'okay', 'confirm', 'book it', 'do it', 'go ahead'],
        'es': ['sí', 'si', 'claro', 'vale', 'confirmar', 'ok', 'bueno', 'adelante'],
        'ru': ['да', 'конечно', 'ок', 'хорошо', 'подтверждаю', 'ладно', 'давай', 'угу'],
        'pt': ['sim', 'claro', 'ok', 'confirmar', 'pode ser', 'bora'],
        'he': ['כן', 'בסדר', 'אוקי', 'מאשר', 'קדימה'],
    }

    # Rejection words by language
    reject_words = {
        'en': ['no', 'nope', 'cancel', 'never mind', 'forget it', 'stop', 'don\'t'],
        'es': ['no', 'cancelar', 'olvídalo', 'déjalo', 'para'],
        'ru': ['нет', 'отмена', 'отменить', 'забудь', 'стоп', 'не надо'],
        'pt': ['não', 'nao', 'cancelar', 'esquece', 'para'],
        'he': ['לא', 'ביטול', 'עזוב', 'שכח'],
    }

    # Check confirmations
    confirms = confirm_words.get(language, confirm_words['en'])
    if any(word in message_lower for word in confirms):
        return True

    # Check rejections
    rejects = reject_words.get(language, reject_words['en'])
    if any(word in message_lower for word in rejects):
        return False

    return None
